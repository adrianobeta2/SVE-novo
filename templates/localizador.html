<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>sendRegiaoLocalizador</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.1/fabric.min.js"></script>
    <style>
        body {
            font-family: 'Arial', sans-serif;
            background-color: #f0f2f5;
            color: #333;
            margin: 0;
            padding: 20px;
        }

        h1 {
            text-align: center;
            font-size: 2.5em;
            color: #333;
        }

        h1 span {
            font-weight: bold;
        }

        #controls {
            display: flex;
            flex-wrap: wrap;
            justify-content: center;
            align-items: center;
            padding: 15px;
            background: #fff;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            border-radius: 20px;
            margin-bottom: 20px;
            border: 2px solid #007bff;
            border-radius: 20px;
        }

        #controls button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px;
            font-size: 16px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        #controls button:hover {
            background-color: #0056b3;
        }

        #controls label {
            margin: 5px 10px;
            font-size: 14px;
            color: #918a91;
        }

        #controls input {
            width: 60px;
            padding: 5px;
            border-radius: 20px;
            border: 1px solid #ddd;
            text-align: center;
            background-color: #f5f2f2;
        }

        #controls input:focus {
            border-color: #007bff;
            outline: none;
        }

        .status-label {
            padding: 8px 12px;
            border-radius: 20px;
            font-weight: bold;
            color: white;
            display: inline-block;
        }

        .status-ok {
            background-color: #28a745;
        }

        .status-nok {
            background-color: #dc3545;
        }

        #canvas {
            border: 2px solid #007bff;
            border-radius: 8px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }

        #results {
            border: 2px solid #007bff;
            border-radius: 20px;
            margin-top: 20px;
            padding: 10px;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }
        
    
        #coordinates {
            border: 2px solid #007bff;
            border-radius: 20px;
            margin-top: 20px; /* Ajuste a margem superior conforme necessário */
            margin-top: 20px;
            padding: 10px;
            background: #fff;
            border-radius: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }



        select {
            padding: 5px;
            border: 1px solid #ddd;
            border-radius: 20px;
            margin-left: 20px;
            font-size: 14px;
        }

        select:focus {
            border-color: #007bff;
            outline: none;
        }

        .button-execute {
            font-size: 30px;
            font-weight: bold;
            background-color: #28a745;
            color: white;
            border: none;
            padding: 15px 25px;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s ease;
            margin-top: 10px;
        }

        .button-execute:hover {
            background-color: #218838;
        }

        .button-live {
            font-size: 14px;
            background-color: #dc3545;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 10px;
        }
        .button-gray {
            font-size: 10px;
            background-color: #6e696a;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 10px;
        }

        .button-referenceImg {
            font-size: 14px;
            background-color: #ffef09;
            color: #0e0000;
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 10px;
            margin-left: 200px;
        }

        .button-limites {
            font-size: 14px;
            background-color: #700e74;
            color: hwb(0 100% 0%);
            border: none;
            padding: 10px 20px;
            border-radius: 20px;
            cursor: pointer;
            margin-top: 10px;
            margin-left: 70px;
        }

        #programa-section{
            
            border: 2px solid #007bff;
            border-radius: 20px;
        }

        
        
        #label-roisection{
   
            margin-left: 80px;
        }

        .button-live:hover {
            background-color: #c82333;
        }

        .flex-container {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            gap: 20px;
        }
        /* Estilo padrão do botão */
        #togglePanMode {
            background-color: #4CAF50; /* Verde */
            color: white;
            border: none;
            padding: 10px 20px;
            cursor: pointer;
            border-radius: 5px;
            transition: background-color 0.3s ease;
        }

        /* Estilo quando o modo "pan" estiver ativo */
        #togglePanMode.pan-active {
            background-color: #f44336; /* Vermelho */
        }

        .flex-container > div {
            flex: 1;
        }
        /* Estilo para a label no canto superior direito */
        #programa-label {
            position: absolute;
            top: 10px;
            right: 20px;
            font-size: 22px;
            color: white;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div style="display: flex; align-items: center; justify-content: center;">
        <div style="margin-right: 10px;">
            <!-- Elemento que ficará à esquerda do h1 -->
            <input type="radio" name="theme" value="light" onclick="setTheme('light')" >
            <input type="radio" name="theme" value="dark" onclick="setTheme('dark')"checked>
        </div>
         <!-- Label para exibir o programa selecionado -->
        <div id="programa-label"></div>
        <h1 id="titulo">
            
            <span>Ajuste de Posição</span>
        </h1>
    </div>

    <div id="controls">
        <button id="drawRectangleBtn" onclick="setMode('drawRectangle')">Desenhar Retângulo</button>
        <button id="drawCircleBtn" onclick="setMode('drawCircle')">Desenhar Círculo</button>
        <button id="editBtn" onclick="setMode('edit')">Editar ROIs</button>
        <button onclick="deleteAllROIs()">Apagar Todos os ROIs</button>
        <button onclick="zoomIn()">Zoom In</button>
        <button onclick="zoomOut()">Zoom Out</button>
        <button onclick="resetZoom()">Resetar Zoom</button>
        <button id="togglePanMode">Pan</button>
        <button id="sendRegionBtn" onclick="sendRegiaoLocalizador()">Enviar Regiao de Interesse</button>
        <button id="TemplateBtn" onclick="Template()">Enviar Template</button>
    </div>

    <div class="flex-container">
        <!-- Coluna com o botão e o canvas -->
        <div>
            <canvas id="canvas" width="800" height="600"></canvas>
        </div>

        <!-- Resultados do lado direito -->
        <div>
            <div>
            

            
            
           
        </div>           
            <div id="coordinates"></div>
        </div>
    </div>

    <!-- Incluindo o arquivo JavaScript da pasta static -->
    <script src="{{ url_for('static', filename='servidor.js') }}"></script>
    <script>
        setTheme('dark'); // Define o tema escuro como padrão
        const canvas = new fabric.Canvas('canvas', {
            selection: false,
        });

        let currentMode = 'drawRectangle';
        let isDrawing = false;
        let shape;
        let startX, startY;
        let imageScaleX = 1, imageScaleY = 1;


        // mensgaem de inicial
        const criarZonaInteresse = document.getElementById('coordinates');
        criarZonaInteresse.innerHTML = '<strong>Crie e envie a região de Interesse!</strong><br>';    

        function setTheme(theme) {
            const h1 = document.getElementById('titulo');
            const controles = document.getElementById('controls');
            const resultados = document.getElementById('results'); 
            const coordenadas = document.getElementById('coordinates');
          
            if (theme === 'dark') {
                document.body.style.backgroundColor = '#060707';
                document.body.style.color = 'white';
                h1.style.color = 'white'; 
                controles.style.backgroundColor =  '#333232';
                //resultados.style.backgroundColor =  '#333232';
                coordenadas.style.backgroundColor =  '#333232';
                //controlesInput.style.color = 'white'
            } else {
                document.body.style.backgroundColor = '#f0f2f5';
                document.body.style.color = '#333';
                h1.style.color = '#333'; 
                controles.style.backgroundColor =  '#fff';
                resultados.style.backgroundColor =  '#fff';
                coordenadas.style.backgroundColor =  '#fff';
                
            }
        }

        
        let blinkInterval = null;

         

        function startBlink(buttonId) {
            stopBlink(); // Para qualquer outro botão piscando
            const button = document.getElementById(buttonId);
            
            if (!button) return;

            blinkInterval = setInterval(() => {
                button.style.visibility = (button.style.visibility === 'hidden') ? 'visible' : 'hidden';
            }, 350);
        }

        function stopBlink() {
            clearInterval(blinkInterval);
            blinkInterval = null;

            document.querySelectorAll("button").forEach(btn => {
                btn.style.visibility = 'visible';
            });
        }

        async function loadImage(url) {
            fabric.Image.fromURL(url, function(img) {
                img.scaleToWidth(800);
                img.scaleToHeight(600);
                img.selectable = false;
                img.evented = false;
                imageScaleX = img.scaleX;
                imageScaleY = img.scaleY;
                canvas.add(img).sendToBack();
            });
        }

        async function fetchImage() {
            const response = await fetch('/get_image');
            const data = await response.json();
            await loadImage(data.image_url);
        }

        function setMode(mode) {
            // Restaura o estilo de todos os botões
            const buttons = document.querySelectorAll('button');
            buttons.forEach(button => {
                button.style.backgroundColor = '';
                button.style.color = '';
            });
             // Define o modo atual
            currentMode = mode;
            isDrawing = false;
            canvas.selection = mode === 'edit';

                    // Altera o estilo do botão selecionado
            const selectedButton = document.getElementById(`${mode}Btn`);
            if (selectedButton) {
                selectedButton.style.backgroundColor = '#00ff3c'; // Cor de fundo azul
                selectedButton.style.color = '#FFFFFF'; // Cor do texto branco
            }

            canvas.getObjects().forEach(obj => {
                if (obj.type === 'rect' || obj.type === 'circle') {
                    obj.selectable = mode === 'edit';
                    obj.evented = mode === 'edit';
                }
            });
        }

        let isPanMode = false; // Variável para controlar o modo "pan"
        let isDragging = false; // Variável para controlar o arrasto no modo "pan"
        let lastPosX = 0, lastPosY = 0; // Armazenar a última posição do mouse
        
        // Função para alternar o modo "pan"
        document.getElementById('togglePanMode').addEventListener('click', function() {
            isPanMode = !isPanMode; // Alterna entre ativo e inativo
            this.textContent = isPanMode ? "Desativar Pan" : "Ativar Pan";
            canvas.selection = !isPanMode; // Desativa a seleção de objetos no modo "pan"
            canvas.defaultCursor = isPanMode ? "grab" : "default"; // Altera o cursor

             // Alterna a classe "pan-active" para mudar o estilo do botão
             this.classList.toggle('pan-active', isPanMode);
        });
        
        // Evento de mouse down
        canvas.on('mouse:down', function(event) {
            if (currentMode === 'edit' && event.target) {
                // Modo de edição: permite mover objetos
                isDragging = false; // Desativa o arrasto do modo "pan"
                return;
            }
        
            if (isPanMode) {
                // Modo "pan": inicia o arrasto
                isDragging = true;
                lastPosX = event.e.clientX;
                lastPosY = event.e.clientY;
                canvas.defaultCursor = "grabbing"; // Altera o cursor durante o arrasto
            } else if (currentMode === 'edit') { 
                return; // Modo de edição, não faz nada
            } else {
                // Modo de desenho: inicia o desenho de formas
                isDrawing = true;
                const pointer = canvas.getPointer(event.e);
                startX = pointer.x;
                startY = pointer.y;
        
                if (currentMode === 'drawRectangle') {
                    shape = new fabric.Rect({
                        left: startX,
                        top: startY,
                        fill: 'rgba(255, 0, 0, 0.1)',
                        stroke: 'lime',
                        strokeWidth: 2,
                        width: 0,
                        height: 0,
                    });
                } else if (currentMode === 'drawCircle') {
                    shape = new fabric.Circle({
                        left: startX,
                        top: startY,
                        fill: 'rgba(255, 0, 0, 0.1)',
                        stroke: 'lime',
                        strokeWidth: 2,
                        radius: 0,
                    });
                }
                canvas.add(shape);
            }
        });
        
        // Evento de mouse move
        canvas.on('mouse:move', function(event) {
            if (currentMode === 'edit' && event.target) {
                // Modo de edição: permite mover objetos
                isDragging = false; // Desativa o arrasto do modo "pan"
                return;
            }
        
            if (isPanMode && isDragging) {
                // Modo "pan": move o canvas
                const deltaX = event.e.clientX - lastPosX;
                const deltaY = event.e.clientY - lastPosY;
                canvas.relativePan({ x: deltaX, y: deltaY });
                lastPosX = event.e.clientX;
                lastPosY = event.e.clientY;
            } else if (isDrawing) {
                // Modo de desenho: atualiza a forma sendo desenhada
                const pointer = canvas.getPointer(event.e);
                if (currentMode === 'drawRectangle') {
                    const width = pointer.x - startX;
                    const height = pointer.y - startY;
                    shape.set({
                        width: Math.abs(width),
                        height: Math.abs(height),
                        left: width < 0 ? pointer.x : startX,
                        top: height < 0 ? pointer.y : startY,
                    });
                } else if (currentMode === 'drawCircle') {
                    const radius = Math.sqrt(
                        Math.pow(pointer.x - startX, 2) +
                        Math.pow(pointer.y - startY, 2)
                    );
                    shape.set({
                        radius: radius,
                        left: startX - radius,
                        top: startY - radius,
                    });
                }
                canvas.renderAll();
            }
        });
        
        // Evento de mouse up
        canvas.on('mouse:up', function() {
            if (isPanMode) {
                // Modo "pan": finaliza o arrasto
                isDragging = false;
                canvas.defaultCursor = "grab"; // Restaura o cursor
            } else if (isDrawing || currentMode === 'edit') {
                // Modo de desenho: finaliza o desenho
                isDrawing = false;
                shape.set({ selectable: true, evented: true });
                updateCoordinates();
                canvas.renderAll();
            }
        });
                // Alterar a cor depois
        function changeRectangleColor(rectangle, fillColor, strokeColor) {
            rectangle.set({
                fill: fillColor || rectangle.fill, // Atualiza o preenchimento, se fornecido
                stroke: strokeColor || rectangle.stroke, // Atualiza o contorno, se fornecido
            });

            canvas.renderAll(); // Renderiza as mudanças no canvas
        }

        // Função para alterar a cor de preenchimento e borda de um círculo
        function changeCircleColor(circle, fillColor, strokeColor) {
            circle.set({
                fill: fillColor || circle.fill, // Atualiza o preenchimento, se fornecido
                stroke: strokeColor || circle.stroke, // Atualiza o contorno, se fornecido
            });
            canvas.renderAll(); // Renderiza o canvas para aplicar as mudanças
        }
        function getAdjustedCoordinates(obj) {
            if (obj.type === 'rect') {
                const { left, top, width, height, scaleX, scaleY } = obj;
                return {
                    x: (left / imageScaleX).toFixed(1),
                    y: (top / imageScaleY).toFixed(1),
                    width: ((width * scaleX) / imageScaleX).toFixed(1),
                    height: ((height * scaleY) / imageScaleY).toFixed(1),
                };
            } else if (obj.type === 'circle') {
                const { left, top, radius, scaleX, scaleY } = obj;
                return {
                    centerX: ((left + radius) / imageScaleX).toFixed(1),
                    centerY: ((top + radius) / imageScaleY).toFixed(1),
                    radiusX: ((radius * scaleX) / imageScaleX).toFixed(1),
                    radiusY: ((radius * scaleY) / imageScaleY).toFixed(1),
                };
            }
            return null;
        }

        function updateCoordinates() {
            const coordinatesDiv = document.getElementById('coordinates');
            coordinatesDiv.innerHTML = '<strong>Coordenadas das ROIs:</strong><br>';
            canvas.getObjects().forEach(obj => {
                if (obj.type === 'rect' || obj.type === 'circle') {
                    const adjusted = getAdjustedCoordinates(obj);
                    if (adjusted) {
                        if (obj.type === 'rect') {
                            coordinatesDiv.innerHTML += `Retângulo - x: ${adjusted.x}, y: ${adjusted.y}, width: ${adjusted.width}, height: ${adjusted.height}<br>`;
                        } else if (obj.type === 'circle') {
                            coordinatesDiv.innerHTML += `Círculo - centerX: ${adjusted.centerX}, centerY: ${adjusted.centerY}, radiusX: ${adjusted.radiusX}, radiusY: ${adjusted.radiusY}<br>`;
                        }
                    }
                }
            });
        }

        async function sendData() {
            const rois = canvas.getObjects().filter(obj => obj.type === 'rect' || obj.type === 'circle').map(getAdjustedCoordinates);
            const response = await fetch('/config', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ rois }),
            });

            const adjustments = {
                contrast: 1.2,
                brightness: 10,
                gamma: 1.0,
            };

            await fetch('/set_adjustments', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(adjustments),
            });
        }

        async function receiveData() {
            const response = await fetch('/config');
            const data = await response.json();

            canvas.clear();
            await fetchImage();

            data.rois.forEach(roi => {
                if (roi.width && roi.height) {
                    const rect = new fabric.Rect({
                        left: roi.x * imageScaleX,
                        top: roi.y * imageScaleY,
                        width: roi.width * imageScaleX,
                        height: roi.height * imageScaleY,
                        fill: 'rgba(255, 0, 0, 0.1)',
                        stroke: 'lime',
                        strokeWidth: 2,
                    });
                    canvas.add(rect);
                } else if (roi.radiusX && roi.radiusY) {
                    const circle = new fabric.Circle({
                        left: (roi.centerX - roi.radiusX) * imageScaleX,
                        top: (roi.centerY - roi.radiusY) * imageScaleY,
                        radius: roi.radiusX * imageScaleX,
                        fill: 'rgba(255, 0, 0, 0.1)',
                        stroke: 'lime',
                        strokeWidth: 2,
                    });
                    canvas.add(circle);
                }
            });
            updateCoordinates();
        }

        function deleteAllROIs() {
            const rois = canvas.getObjects().filter(obj => obj.type === 'rect' || obj.type === 'circle');
            rois.forEach(roi => canvas.remove(roi));
            updateCoordinates();
        }

        function zoomIn() {
            canvas.setZoom(canvas.getZoom() * 1.1);
        }

        function zoomOut() {
            canvas.setZoom(canvas.getZoom() / 1.1);
        }

        function resetZoom() {
            canvas.setZoom(1);
        }
        let cameraConfig = null;
        async function fetchCameraConfig() {
            if (cameraConfig !== null) {
                return cameraConfig; // já carregado
            }
            try {
                const response = await fetch('/get_cameras');
                if (!response.ok) {
                throw new Error(`Erro ao buscar config: ${response.statusText}`);
                }
    
                cameraConfig = await response.json();
                serial_camera_1 = cameraConfig.cam_basler_1;
                serial_camera_2 = cameraConfig.cam_basler_2;
                return cameraConfig;
            } catch (error) {
                console.error("Erro ao carregar configurações das câmeras:", error);
                return null;
            }
    
        }
        // Função para carregar a imagem inicial
        
        // Substituir endpoints pelos definidos no servidor Flask
         // Substituir endpoints pelos definidos no servidor Flask
         async function fetchImage() {
            let camera  = 0;
            let tipo = "";
            let response = null;
            const urlParams = new URLSearchParams(window.location.search);
            const programa = urlParams.get('programa');
            const camera_get = urlParams.get('camera');
            programaSelect = programa;
          
           
            const selectedValue = parseInt(camera_get,10); 
            const config = await fetchCameraConfig();
            tipo = config.tipo;
            if(selectedValue === 1){

              if(tipo == "basler"){  
              camera = config.cam_basler_1;
              }
              else{
              camera = config.cam_1; 
              }
            }
            else{
                if(tipo == "basler"){  
                    camera = config.cam_basler_2;
                    }
                    else{
                    camera = config.cam_2; 
                 }
            }
            
            
            if(tipo ==="webcam"){
                camera = encodeURIComponent(camera);  // codifica o path 
                response = await fetch(`${SERVER_URL}/capture_webcam/${camera}`);
            }
            else{
                response = await fetch(`${SERVER_URL}/capture/${camera}`);
            }
            

            const imageBlob = await response.blob(); // Obter o blob da imagem
            const imageUrl = URL.createObjectURL(imageBlob); // Criar uma URL para o blob da imagem      

            await loadImage(imageUrl); // Carregar a imagem no canvas// Definir a imagem como plano de fundo
           
        }


         

        async function sendData() {
            // Obter as ROIs ajustadas
            const rois = canvas.getObjects()
                .filter(obj => obj.type === 'rect' || obj.type === 'circle')
                .map(obj => {
                    const adjusted = getAdjustedCoordinates(obj);

                    if(obj.type === 'rect'){
                    return {
                        
                        x: parseInt(adjusted.x),
                        y: parseInt(adjusted.y),
                        width: parseInt(adjusted.width),
                        height: parseInt(adjusted.height),
                    };
                  }else{
                    return {
                        
                        x: parseInt(adjusted.centerX),
                        y: parseInt(adjusted.centerY),
                        width: parseInt(adjusted.radiusX),
                        height: parseInt(adjusted.radiusY),
                    };
                  }
                });

            // Garantir que pelo menos uma ROI está presente
            if (rois.length === 0) {
                alert("Nenhuma ROI encontrada para envio.");
                return;
            }

            // Selecionar a última ROI criada (ou outro critério, se necessário)
            const roi = rois[rois.length - 1];

            // Obter valores de contraste, brilho e gamma
            let contrastValue = document.getElementById('contrast').value;
            let brightnessValue = document.getElementById('brightness').value;
            let gammaValue = document.getElementById('gamma').value;

            // Adicionar seleção de seção ROI (ex: ROI1, ROI2, ROI3)
            const selectedSection = document.getElementById('roi-section').value;

           
            // Garantir que a seção foi selecionada
            if (!selectedSection) {
                alert("Por favor, selecione uma seção de ROI.");
                return;
            }

            // Ajustes de imagem
            const adjustments = {
                contrast: contrastValue, // Valores ajustáveis
                brightness: brightnessValue,
                gamma: gammaValue,
                roi: {
                    section: selectedSection, // Adiciona a seção selecionada
                    ...roi,
                },
            };

            try {
                const response = await fetch(`${SERVER_URL}/config`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(adjustments),
                });

                if (!response.ok) {
                    const errorMessage = await response.text();
                    console.error("Erro ao enviar dados:", errorMessage);
                    alert("Erro ao enviar dados. Verifique o console para mais detalhes.");
                } else {
                    const coordinatesDiv = document.getElementById('coordinates');
                    coordinatesDiv.innerHTML = '<strong>Dados enviados com sucesso!</strong><br>';
                }
            } catch (error) {
                console.error("Erro de comunicação com o servidor:", error);
                alert("Erro ao conectar ao servidor.");
            }
        }


        async function sendRegiaoLocalizador() {
            // Obter as ROIs ajustadas

            startBlink("TemplateBtn");
            const rois = canvas.getObjects()
                .filter(obj => obj.type === 'rect' || obj.type === 'circle')
                .map(obj => {
                    const adjusted = getAdjustedCoordinates(obj);
        
                    if (obj.type === 'rect') {
                        return {
                            x_interes: parseInt(adjusted.x),
                            y_interes: parseInt(adjusted.y),
                            width_interes: parseInt(adjusted.width),
                            height_interes: parseInt(adjusted.height),
                        };
                    } else {
                        return {
                            x_interes: parseInt(adjusted.centerX),
                            y_interes: parseInt(adjusted.centerY),
                            width_interes: parseInt(adjusted.radiusX),
                            height_interes: parseInt(adjusted.radiusY),
                        };
                    }
                });
        
            // Garantir que pelo menos uma ROI está presente
            if (rois.length === 0) {
                alert("Nenhuma ROI encontrada para envio.");
                return;
            }
        
            // Selecionar a última ROI criada (ou outro critério, se necessário)
            const roi = rois[rois.length - 1];
        
            try {
                // Criar um novo objeto contendo o programa e os dados da ROI
                const requestData = {
                    camera: cameraSelect,
                    programa: programaSelect,  // Programa fica fora da ROI
                    roi: roi
                };


                const response = await fetch(`${SERVER_URL}/coord_ref`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData),
                });
        
                if (!response.ok) {
                    const errorMessage = await response.text();
                    console.error("Erro ao enviar dados:", errorMessage);
                    alert("Erro ao enviar dados. Verifique o console para mais detalhes.");
                } else {
                    const coordinatesDiv = document.getElementById('coordinates');
                    coordinatesDiv.innerHTML = '<strong>Dados enviados com sucesso! Agora, crie o template!</strong><br>';
                }
            } catch (error) {
                console.error("Erro de comunicação com o servidor:", error);
                alert("Erro ao conectar ao servidor.");
            }
        }

        async function Template() {

            stopBlink("TemplateBtn");
            // Obter as ROIs ajustadas
            const rois = canvas.getObjects()
                .filter(obj => obj.type === 'rect' || obj.type === 'circle')
                .map(obj => {
                    const adjusted = getAdjustedCoordinates(obj);
        
                    if (obj.type === 'rect') {
                        return {
                            x: parseInt(adjusted.x),
                            y: parseInt(adjusted.y),
                            width: parseInt(adjusted.width),
                            height: parseInt(adjusted.height),
                        };
                    } else {
                        return {
                            x: parseInt(adjusted.centerX),
                            y: parseInt(adjusted.centerY),
                            width: parseInt(adjusted.radiusX),
                            height: parseInt(adjusted.radiusY),
                        };
                    }
                });
        
            // Garantir que pelo menos uma ROI está presente
            if (rois.length === 0) {
                alert("Nenhuma ROI encontrada para envio.");
                return;
            }
        
            // Selecionar a última ROI criada (ou outro critério, se necessário)
            const roi = rois[rois.length - 1];
        
            try {

                // Criar um novo objeto contendo o programa e os dados da ROI
                const requestData = {
                    camera: cameraSelect,
                    programa: programaSelect,  // Programa fica fora da ROI
                    roi: roi
                };
                const response = await fetch(`${SERVER_URL}/template`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(requestData),
                });
                
                if (!response.ok) {
                    const errorMessage = await response.text();
                    console.error("Erro ao enviar dados:", errorMessage);
                    alert("Erro ao enviar dados. Verifique o console para mais detalhes.");
                } else {
                    const coordinatesDiv = document.getElementById('coordinates');
                    coordinatesDiv.innerHTML = '<strong>Template enviado com sucesso!</strong><br>';
                }
            } catch (error) {
                console.error("Erro de comunicação com o servidor:", error);
                alert("Erro ao conectar ao servidor.");
            }
        }
        
        
        let retanguloRef = null
        let circuloRef = null
        
        async function receiveData() {
            // Adicionar seleção de seção ROI (ex: ROI1, ROI2, ROI3)
            await fetchImage();
            const selectedSection = document.getElementById('roi-section').value;
            const response = await fetch(`${SERVER_URL}/config?section=${selectedSection}`);

            if (!response.ok) {
                console.error("Erro ao obter os dados do servidor:", await response.text());
                return;
            }

            const data = await response.json();

            // Log para depuração
            console.log("Dados recebidos do servidor:", data);

            // Atualizar os campos de brilho, contraste e gamma
            document.getElementById('contrast').value = data.contrast;
            document.getElementById('brightness').value = data.brightness;
            document.getElementById('gamma').value = data.gamma;

            // Verificar se existe uma propriedade 'roi'
            if (data.roi) {
                console.log("ROI detectado:", data.roi);

                const roi = data.roi;
                //canvas.clear();
                

                // Caso o ROI seja um retângulo
                if (roi.width != roi.height) {
                    const rect = new fabric.Rect({
                        left: roi.x * imageScaleX,
                        top: roi.y * imageScaleY,
                        width: roi.width * imageScaleX,
                        height: roi.height * imageScaleY,
                        fill: 'rgba(255, 0, 0, 0.1)',
                        stroke: 'lime',
                        strokeWidth: 2,
                    });
                    
                    retanguloRef = rect; 
                   
                    canvas.add(rect);
                } else if (roi.width == roi.height) {
                    const circle = new fabric.Circle({
                        left: (roi.x - roi.width) * imageScaleX,
                        top: (roi.y - roi.height) * imageScaleY,
                        radius: roi.width * imageScaleX,
                        fill: 'rgba(255, 0, 0, 0.1)',
                        stroke: 'lime',
                        strokeWidth: 2,
                    });
                    circuloRef =circle
                   
                    canvas.add(circle);
                    
                }

                updateCoordinates();
            } else {
                console.warn("Nenhuma ROI encontrada na resposta.");
            }
        }

        
        let programaSelect = null;
        let cameraSelect = null;
        
        
        window.onload = function() {
                const urlParams = new URLSearchParams(window.location.search);
                const programa = urlParams.get('programa');
                const camera = urlParams.get('camera');
                programaSelect = programa;
                cameraSelect = camera;
                startBlink("sendRegionBtn");
                if (programa) {
                    document.getElementById('programa-label').textContent = "Programa: "+programa;
                }
         };
    
        
        // Carregar a imagem inicial ao carregar a página
        fetchImage();
        //receiveData();
    </script>
    
</body>
</html>

